<!doctype html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>AWS Meetup Melbourne - Microservices</title>
		<meta name="description" content="Angular Meetup Melbourne - Protractor JS">
		<meta name="author" content="Braiden Judd">
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<link rel="stylesheet" href="css/style.css">
	</head>

	<body>
		<textarea id="source">

		name: inverse
		layout: true
		class: center, middle

		---

		class: inverse

		# Microservices
		*Or fine grained architectures*

		---

		class: inverse

		# Braiden Judd
		> Work at Suncorp
		>
		> @pragmaticyclist

		---
		
		class: inverse

		## What is your current experience with microservices?

		http://braiden.firebaseapp.com

		---

		class: inverse

		# Agenda

		### Part I: Introduction
		### Part II: Benefits
		### Part III: Considerations
		### Part IV: Getting started

		---

		class: inverse

		# Part I: Introduction
		*OK, what?*

		---

		## Let's start with a definition

		### What does microservices mean?

		![Alt text](img/microservices.png)

		???

		* COLLECTION
		* LOOSELY COUPLED, HIGHLY COHESIVE
		* SMALL, 1000 lines. APP FRAMEWORKS HELP
		* BY PROBLEM DOMAIN OR BUSINESS CONCEPT
		* PEERS WORKING TOGETHER
		* STANDARD INTERFACES
		* SOFTWARE TEAM ANALOGY

		...

		* A collection of services that by working together do something useful for the a customer.
		* Loosely coupled, highly cohesive
		* Small-ish, < 1000 lines of code, this can actually mean a lot with modern day framworks.
		* Based around problem domains or a business concept.
		* Services are peers of each other, none really being more important then another.
		* Solid well defined interfaces between them
		* Analogy could be a software team, some people are more productive, some less. All communicate over standard forms of communication but all are autonomous, but they all work towards a common goal.

		---

		## AWS Cost Service

		### Unloaded

		![Alt text](img/aws_not_loaded.png)

		---

		## AWS Cost Service

		### Loaded

		![Alt text](img/aws_loaded.png)

		???

		* LOADING 3 DIFFERENT SERVICES

		---

		## Netflix
		### Recomended for me 

		![Alt text](img/netflix.png)

		* AGAIN, GOES DOWN MAYBE SHOWS POPULAR MOVIES INSTEAD

		---

		## Amazon

		### Books I may also like

		![Alt text](img/amazon.png)

		???

		* AGAIN, GOES DOWN DOES NOT BREAK THE CUSTOMER EXPERIENCE, DEGRADES IT

		---

		class: inverse

		# Part II: Benefits
		*OK, why?*

		???

		* So now we have a definition, why would we want to do something like this?

		---

		## Brings freedom and choice

		### Empowerment

		![Alt text](img/interconnects.png)

		???

		* EMPOWERED PEOPLE ARE AUTONOMOUS
		* TRY NEW TECH WITH LESS RISK
		* ALLOWS TO HIRE PEOPLE TO SOLVE PROBLEMS NOT AS A JAVA DEV

		...

		* Empowerment - Services solves a problem that can be owned by a team or a group. Empowering them to solve the problem how they want, we just dictate the interface
		* Less risk in trialing a new technology
		* Easy to enable new technology, we can trial new technologies on lesser services (in terms of complexity of the problems they solve). Enables you to hire people to solve problems not for their knowledge of a technology stack.

		---

		## Scalability

		### Flexibility in Scaling

		![Alt text](img/finegrainedscalability.png)

		???

		* FINE GRAINED SCALING
		* OPTIMISE AND TWEAK CERTAIN PARTS, LANGUAGE THAT SUITS PROBLEM
		* SCALING INNOVATION AND PRODUCT DELIVERY

		...

		* Perhaps but we can scale a lot better in a microservices world, we can scale the 'hot' services rather than just scale the whole thing. It also helps with DB scaling, DB scaling can be hard however in a small fine grained architecture persistance layers are rarely so large scaling becomes a major issue.
		* Scalability of innovation and product delivery. Teams are no longer planning independent changes, rather they can define the interface to their service and build changes within those bounds without the knowledge or the service customers.
		* Fine grained scalability, we can scale, optimise or tweak individual parts of our application as needed rather than just throwing more hardware at the problem.

		---

		## Agility

		### Architecture that fits the way you work

		![Alt text](img/agility.png)

		???

		* AGILE MANIFESTO - TRIAL, MEASURE, LEARN, CORRECT, REPEAT
		* DEPLOY PARTS INDIVIDUALLY, BECAUSE LOOSELY COUPLED
		* NEW PAYMENT TECH

		...

		* The original AGILE manifesto was focused on trial, measure and correction the repeat. Microservices is an obvious fit for that working model as you can trial new technologies, ways of working, even ide's or hosting. Measure the results, learn and feed into the next service.
		* Can deploy services, and therefore parts of your application individually. No large cordinated deployments with a large amount of associated risk.
		* Means you are able to go from feature inception to delivery a lot faster.

		---

		## Resiliency

		### Cloud native architecture

		![Alt text](img/resiliency.png)

		???

		* HANDLE FAILURE, ISOLATED, LOOSELY COUPLED
		* CUSTOMER EXPERIENCE DEGRADED NOT REMOVED
		* LESS RISK, ALL EGGS IN ONE BASKET

		...


		* Services that are loosely coupled can continue even while one of their peers has failed. A great example of this is the Netflix and their cloud native, non-fragile archnitecture.
		* Easier to identify, with good logging where bottlenecks are occuring, but measuring end-to-end uses of an applications and measure the response time of each service.
		* A service can attempt to call another service, and if that fails perhaps default back to a more generic defaut behaviour.
		* By creating *Bulk Heads*, just like in a ship, you can stop failures propergating accross the system by isolating parts of the system.
		* Always set timeouts.
		* All leads to less risk, no all eggs in one basket

		---

		## Geography

		### Distributed Workforce

		![Alt text](img/geography.png)

		???

		* DISTRIBUTED AGILE IS HARD
		* HAVE TEAMS DISTRIBUTED AS YOU PLAN TO DISTRIBUTE YOUR APPLICATION
		* SEARCH FOR TALENT MORE PLACES

		...

		* Distrubuted AGILE is hard
		* With microservices you could have distributed teams, each location solving a different problem and therefore working on different services
		* Allows you to spread you search for talent past your local area

		---

		class: inverse

		# Part III: Considerations
		*Ok, how?*

		---

		## Where do I standardise and where do I allow autonomy?

		![Alt text](img/standardisation.png)

		???

		* AUTONOMY V STANDARD
		* MANUFACTORING WANT STANDARDS
		* STARTUPS WANT AUTONOMY
		* LIVE SOMEWHERE IN THE MIDDLE

		...

		* Find a place on a line
		* Enterprises tend to er on standardise
		* Startups tend to be on the other side
		* I am going to show there are parts that need standardisation and there are parts that are free to be autonomous

		---

		## Interfaces

		### Pipes and connections

		![Alt text](img/freedom_v_autonomy.png)

		???

		* STANDARDISE THE PIPES AND CONNECTIONS
		* USE HTTP, HTTP ERROR CODES. STANDARD WELL KNOWN TECH
		* PROVEN AT WEB SCALE
		* HTTP IS LANGUAGE AGNOSTIC
		* FREEDOM WITHIN SERVICES 

		...

		* Standardise all the pipes and connections, allow autonomy and discretion in the service implementation
		* Important to define the interfaces between them, not necessarily the technology that supports them.
		* REST is a good and well defined standard. Use for the standard error codes HTTP provides.

		---

		## Deployment

		### Deploy quickly and often

		![Alt text](img/baddeployments.png)

		???

		* DEPLOY QUICKLY - As soon as release is ready
		* DEPLOY OFTEN - Deploy once a day not change thursday
		* ALL ABOUT LOWERING RISK OF CHANGE
		* GRAPH

		...

		* By deploying quickly i mean when the release is ready it should rapidly move to production.
		
		---

		## Deployment

		### Deploy quickly and often

		![Alt text](img/gooddeployments.png)

		???

		* STANDARDISE YOUR DEPLOYMENT TOOLS AND PROCESS.
		* DIFFERENT TECH, SAME TOOLS AND PROCESS
		* Chef, Puppet or Ansible
		* DOCKER

		...

		* Often means deploying small production ready changes
		* Lowers the risk of changes as they are smaller, less coupled and therefore more easy to rollback
		* Standardise the deployment process, so for example while you might have ruby on rails, django and node.js services, they all should be deployed the same way.
		* Use Chef, Puppet or Ansible, so to deploy each app you just run a playbook or cookbook, while these may very from service to actually deploy each service it will be the same.
		* Docker could help with things like this.

		---

		## Integration Testing

		### Consumer driven contracts

		![Alt text](img/integrationtesting.png)

		???

		* CONSUMER WRITES TESTS
		* SERVICE RUN THEMS

		...

		* Get the customers of your service write tests for your services they consume, this forms a contract
		* Run these tests before each deployment

		---

		## Monitoring and Logging

		### Aggregate to create and end-to-end picture of your application

		![Alt text](img/logging.png)

		???

		* LOG EVERYTHING
		* USE LOG AGGREGATION TOOLS
		* PROACTIVE NOT REACTIVE
		* STATUS CODES AND LATENCY
		* TRANSACTION IDs

		...

		* When something is broken on a monolithic system, it is very easy to see what is broken.
		* In the microservice world, it is much more difficult. As it could be one of N disparate services.
		* Use a log aggregation tools, there are free open source options like logstash. But there are many great options that now play in this place.
		* Logging as a proactive and reactive tool, getting response times. Knowing what normal is. HTTP Error codes. 
		* Use transaction ID, a unique ID for all service interactions involved in a single request.

		---

		## Automation

		### Goes without saying

		![Alt text](img/automation.gif)

		???

		* A MUST
		* 1 DEPLOY to 150 A MONTH
		* WHEN IS AUTOMATION A BAD THING

		...

		* I was not going to include this slide, but deployments, testing and monitoring must be automated.
		* Can not afford not to automate within a microservices based environment as deployments, testing and monitoring needs to scale.

		---

		## Transactions

		### These are hard

		![Alt text](img/transactions.png)

		???

		* AVOID
		* BE AWARE
		* MAKE ONE SERVICE

		...

		* Should be aware of any transactions occuring accross service boundaries, such as between an ticketing and payment system.
		* Transactions couple services together.
		* These should be avoided where posisble

		---

		## Team structure

		> "organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations" 
		> 
		> M. Conway

		???

		* Conway's law "organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations" 
		
		---

		## Teams divided by Technology

		![Alt text](img/team_structure_tech.png)

		???

		* BAD, SILOED APPLICATION

		...

		* If you divide your team by technology, you will create technology silos in your applications.
		
		---

		## Multifunctional Teams

		![Alt text](img/team_structure_micro.png)

		???

		* GOOD, SILOED SERVICES (LOOSELY COUPLED)
		* HIGH COHESION
		* DISTRIBUTED AGILE

		...

		* If you create multi-skilled teams and each of these work on an individual service to make an application you will get a loosely coupled microservices architecture because of Conway's law.
		* Distributed Agile is quite difficult in practice, this might help if you can co-locate each service team
		

		---

		## Architectural Safety

		### Cars not trains

		![Alt text](img/safety.png)

		???

		* Act like cars not trains
		* TIMEOUTS
		* CIRCUIT BREAKERS
		* BULK HEADS
		* ARCHETYPES
		* NEW SERVICE IMPLEMENT SAFETY THEMSELVES

		...

		* Let people act like cars not trains, where trains are on tracks, stop at the same places and leave at consistant times, cars afford a greater degree of freedom, however within some rule boundaries. These rules can be different from company to company. Like driving on the correct side of the road, it doesn't matter if you choose one side, it matters greatly however that you choose a side and stick with it.
		* Use timeouts, circuit breakers and bulk heads
		* In the references there is a Netflix talk that goes through this in detail.
		* Define archetypes, that developers can use off the shelf to build their services
		* If a service is to use a new technology the team would be expected to build their service conforming to the regulations.

		---

		class: inverse

		# Part IV: Getting started
		*Ok, when?*

		???

		* How we start with microservices
		* This can be hard, but their are benefits

		---

		class: inverse

		name: agenda
		class: middle, center

		## Decision Tree
		![Alt text](img/decisiontree.png)

		???

		* GREENSFIELDS
		* SINGLE DOMAIN
		* LOW RISK
		* REUSE

		...

		* Greenfields, Make your standards in iteration 0 and go for it
		* Suits environments with changing conditions, not largely static applications
		* Is the maintenance, acting on a particular problem domain of the application that could be pulled out as part of the maintenance work?
		* By pulling this functionality into a microservice you can reuse the functionality elsewhere in your ecosystem.
		* Targetting low risk parts of the application is an obvious way to break some of the functionality away.

		---

		class: inverse

		## Netflix - Karyon

		### Microservices Template

		https://github.com/Netflix/karyon

		???

		* Built by Netflix, so heavily integrated with netflix's other open source tools
		* Service registry
		* Property management
		* Status page and health checks
		* Latency monitoring

		---

		class: inverse

		# Take aways

		### Loosely coupled and highly cohesive
		### Small, well defined and limited to a single business concept
		### Standardise the pipes and connectors, allow autonomy in the service implementations
		### Logging is important, aggregate to create and end-to-end picture of your application
		### Standardise the deployment process, deploy often and quickly
		### Understand how team structure can impact your application

		---

		class: inverse

		# Picks

		## Dash - Mac Offline Documentation
		## Podcasts - Arrested DevOps, Food Fight Show, Devchat.tv and AWS Podcast****
		## Firebase
		## S3 and Backups
		## Mountain Goat - Rare Breed

		---

		class: inverse

		# About Me

		### Cyclist
		### Quadcopters
		### Dogs

		???

		* Avid cyclist
		* Quadcopters, nothing stimilates boyish enthusiasm in me like Quadcopters, it is grown up lego. Would love to build an API on my two quadcopters and get them to work together.

		---

		# Go home nature, you're drunk

		![Alt text](img/dogs.png)

		---

		class: inverse

		# Follow up

		> http://martinfowler.com/articles/microservices.html
		> 
		> http://yow.eventer.com/yow-2013-1080/practical-considerations-for-microservice-architectures-by-sam-newman-1389
		>
		> http://www.confreaks.com/videos/2488-railsconf2013-how-to-talk-to-developers

		</textarea>
		<script src="lib/remark/out/remark.min.js" type="text/javascript"></script>
		<script type="text/javascript">
			var slideshow = remark.create();
		</script>
	</body>
</html>
